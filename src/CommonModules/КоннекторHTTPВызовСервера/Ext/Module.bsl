// Используется для библиотеки Коннектор работающий в клиентском контексте

&НаСервере
Функция РазобратьURLСервер(Знач URL) Экспорт

	Схема = "";
	Путь = "";
	Аутентификация = Новый Структура("Пользователь, Пароль", "", "");
	Сервер = "";
	Порт = "";
	Фрагмент = "";
	
	ДопустимыеСхемы = СтрРазделить("http,https", ",");
	
	URLБезСхемы = URL;
	РазбитьСтрокуПоРазделителюСервер(Схема, URLБезСхемы, "://");
	Если ДопустимыеСхемы.Найти(НРег(Схема)) <> Неопределено Тогда
		URL = URLБезСхемы;
	Иначе
		Схема = "";
	КонецЕсли;
	
	Результат = РазделитьПоПервомуНайденномуРазделителюСервер(URL, СтрРазделить("/,?,#", ","));
	URL = Результат[0];
	Если ЗначениеЗаполнено(Результат[2]) Тогда
		Путь = Результат[2] + Результат[1];
	КонецЕсли;
	
	АутентификацияСтрока = "";
	РазбитьСтрокуПоРазделителюСервер(АутентификацияСтрока, URL, "@");
	Если ЗначениеЗаполнено(АутентификацияСтрока) Тогда
		АутентификацияЧасти = СтрРазделить(АутентификацияСтрока, ":");
		Аутентификация.Пользователь = АутентификацияЧасти[0];
		Аутентификация.Пароль       = АутентификацияЧасти[1];
	КонецЕсли;

	// IPv6
	РазбитьСтрокуПоРазделителюСервер(Сервер, URL, "]");
	Если ЗначениеЗаполнено(Сервер) Тогда
		Сервер = Сервер + "]";
	КонецЕсли;
	
	URL = СтрЗаменить(URL, "/", "");
	
	РазбитьСтрокуПоРазделителюСервер(Порт, URL, ":", Истина);
	
	Если Не ЗначениеЗаполнено(Сервер) Тогда
		Сервер = URL;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Порт) Тогда 
		Порт = Число(Порт);
	Иначе
		Порт = 0;
	КонецЕсли;
	
	РазбитьСтрокуПоРазделителюСервер(Фрагмент, Путь, "#", Истина);
	
	ПараметрыЗапроса = ЗаполнитьПараметрыЗапросаСервер(Путь);
	
	Если Не ЗначениеЗаполнено(Схема) Тогда
		Схема = "http";
	КонецЕсли;
	Путь = ?(ЗначениеЗаполнено(Путь), Путь, "/");
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Аутентификация", Аутентификация);
	Результат.Вставить("Сервер", Сервер);
	Результат.Вставить("Порт", Порт);
	Результат.Вставить("Путь", Путь);
	Результат.Вставить("ПараметрыЗапроса", ПараметрыЗапроса);
	Результат.Вставить("Фрагмент", Фрагмент);

	Возврат Результат;
	
КонецФункции

// Вычисляет HMAC (hash-based message authentication code).
//
// Параметры:
//   Ключ - ДвоичныеДанные - секретный ключ.
//   Данные - ДвоичныеДанные - данные, для которых нужно посчитать HMAC.
//   Алгоритм - ХешФункция | Строка - алгоритм | наименование алгоритма, используемый для вычисления хеша.
//
// Возвращаемое значение:
//   ДвоичныеДанные - вычисленное значение HMAC. 
//
&НаСервере
Функция HMAC(Ключ, Данные, ИмяАлгоритма) Экспорт
	
	ДлинаБлока = 64;
	
	Если ТипЗнч(ИмяАлгоритма) = Тип("Строка") И ИмяАлгоритма = "MD5" Тогда
		Алгоритм = ХешФункция.MD5;
	ИначеЕсли ТипЗнч(ИмяАлгоритма) = Тип("Строка") И ИмяАлгоритма = "CRC32" Тогда
		Алгоритм = ХешФункция.CRC32;
	ИначеЕсли ТипЗнч(ИмяАлгоритма) = Тип("Строка") И ИмяАлгоритма = "SHA1" Тогда
		Алгоритм = ХешФункция.SHA1;
	ИначеЕсли ТипЗнч(ИмяАлгоритма) = Тип("Строка") И ИмяАлгоритма = "SHA256" Тогда
		Алгоритм = ХешФункция.SHA256;
	Иначе
		Алгоритм = ИмяАлгоритма;
	КонецЕсли;
	
	Если Ключ.Размер() > ДлинаБлока Тогда
		Хеширование = Новый ХешированиеДанных(Алгоритм);
		Хеширование.Добавить(Ключ);
		
		КлючБуфер = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(Хеширование.ХешСумма);
	Иначе
		КлючБуфер = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(Ключ);
	КонецЕсли;
	
	ИзмененныйКлюч = Новый БуферДвоичныхДанных(ДлинаБлока);
	ИзмененныйКлюч.Записать(0, КлючБуфер);
	
	ВнутреннийКлюч = ИзмененныйКлюч.Скопировать();
	ВнешнийКлюч = ИзмененныйКлюч;
	
	ВнутреннееВыравнивание = Новый БуферДвоичныхДанных(ДлинаБлока);
	ВнешнееВыравнивание = Новый БуферДвоичныхДанных(ДлинаБлока);
	Для Индекс = 0 По ДлинаБлока - 1 Цикл
		ВнутреннееВыравнивание.Установить(Индекс, 54);
		ВнешнееВыравнивание.Установить(Индекс, 92);
	КонецЦикла;
	
	ВнутреннееХеширование = Новый ХешированиеДанных(Алгоритм);
	ВнешнееХеширование = Новый ХешированиеДанных(Алгоритм);
	
	ВнутреннийКлюч.ЗаписатьПобитовоеИсключительноеИли(0, ВнутреннееВыравнивание);
	ВнешнийКлюч.ЗаписатьПобитовоеИсключительноеИли(0, ВнешнееВыравнивание);
	
	ВнешнееХеширование.Добавить(ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(ВнешнийКлюч));
	ВнутреннееХеширование.Добавить(ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(ВнутреннийКлюч));
	
	Если ЗначениеЗаполнено(Данные) Тогда
		ВнутреннееХеширование.Добавить(Данные);
	КонецЕсли;
	
	ВнешнееХеширование.Добавить(ВнутреннееХеширование.ХешСумма);
	
	Возврат ВнешнееХеширование.ХешСумма;

КонецФункции

&НаСервере
Функция КодироватьСтрокуСервер(URL, сСпособКодированияСтроки) Экспорт
	Перем СпособКодирования;
	
	Если сСпособКодированияСтроки = "URLВКодировкеURL" Тогда
		СпособКодирования = СпособКодированияСтроки.URLВКодировкеURL;
	Иначе
		СпособКодирования = СпособКодированияСтроки.КодировкаURL;
	КонецЕсли;
	
	Возврат КодироватьСтроку(URL, СпособКодирования);
КонецФункции

&НаСервере
Функция РаскодироватьСтрокуСервер(URL, сСпособКодированияСтроки) Экспорт
	Перем СпособКодирования;
	
	Если сСпособКодированияСтроки = "URLВКодировкеURL" Тогда
		СпособКодирования = СпособКодированияСтроки.URLВКодировкеURL;
	Иначе
		СпособКодирования = СпособКодированияСтроки.КодировкаURL;
	КонецЕсли;

	Возврат РаскодироватьСтроку(URL, СпособКодирования);
КонецФункции

&НаСервере
Функция КодироватьПараметрыЗапросаСервер(ПараметрыЗапроса) Экспорт
	
	ЧастиПараметрыЗапроса = Новый Массив;
	Для Каждого Параметр Из ПараметрыЗапроса Цикл
		Если ТипЗнч(Параметр.Значение) = Тип("Массив") Тогда
			Значения = Параметр.Значение;
		Иначе
			Значения = Новый Массив;
			Значения.Добавить(Параметр.Значение);
		КонецЕсли;
		
		Если Параметр.Значение = Неопределено Тогда
			ЧастиПараметрыЗапроса.Добавить(Параметр.Ключ);
		Иначе
			Для Каждого Значение Из Значения Цикл
				ЗначениеПараметра = КодироватьСтроку(Значение, СпособКодированияСтроки.КодировкаURL);
				ЧастиПараметрыЗапроса.Добавить(СтрШаблон("%1=%2", Параметр.Ключ, ЗначениеПараметра));
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(ЧастиПараметрыЗапроса, "&");
	
КонецФункции

&НаСервере
Функция ТекущаяУниверсальнаяДатаСервер() Экспорт
	
	Возврат ТекущаяУниверсальнаяДата();
	
КонецФункции

&НаСервере
Функция ПолучитьЗначениеЗаголовкаСервер(ЗаголовокHTTP, ВсеЗаголовки, Ключ = Неопределено) Экспорт
	
	Для Каждого ОчереднойЗаголовок Из ВсеЗаголовки Цикл
		Если НРег(ОчереднойЗаголовок.Ключ) = НРег(ЗаголовокHTTP) Тогда
			Ключ = ОчереднойЗаголовок.Ключ;
			Возврат ОчереднойЗаголовок.Значение;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

&НаСервере
Функция ЗаполнитьПараметрыЗапросаСервер(Путь)

	ПараметрыЗапроса = Новый Соответствие;
	
	Запрос = "";
	РазбитьСтрокуПоРазделителюСервер(Запрос, Путь, "?", Истина);
	Для Каждого СтрокаКлючРавноПараметр Из СтрРазделить(Запрос, "&", Ложь) Цикл
		СтрокаКлючРавноПараметр = РаскодироватьСтроку(
			СтрокаКлючРавноПараметр, СпособКодированияСтроки.URLВКодировкеURL);

		ПозицияРавно = СтрНайти(СтрокаКлючРавноПараметр, "=");
		Если ПозицияРавно = 0 Тогда
			Ключ = СтрокаКлючРавноПараметр;
			Значение = Неопределено;
		Иначе
			Ключ = Лев(СтрокаКлючРавноПараметр, ПозицияРавно - 1);
			Значение = Сред(СтрокаКлючРавноПараметр, ПозицияРавно + 1);
		КонецЕсли;

		Если ПараметрыЗапроса.Получить(Ключ) <> Неопределено Тогда
			Если ТипЗнч(ПараметрыЗапроса[Ключ]) = Тип("Массив") Тогда
				ПараметрыЗапроса[Ключ].Добавить(Значение);
			Иначе
				Значения = Новый Массив;
				Значения.Добавить(ПараметрыЗапроса[Ключ]);
				Значения.Добавить(Значение);
				ПараметрыЗапроса[Ключ] = Значения;
			КонецЕсли;
		Иначе
			ПараметрыЗапроса.Вставить(Ключ, Значение);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ПараметрыЗапроса;

КонецФункции

&НаСервере
Процедура РазбитьСтрокуПоРазделителюСервер(ИзвлекаемаяЧасть, ОстальнаяЧасть, Разделитель, Инверсия = Ложь)
	
	Индекс = СтрНайти(ОстальнаяЧасть, Разделитель);
	Если Индекс Тогда
		ИзвлекаемаяЧасть = Лев(ОстальнаяЧасть, Индекс - 1);
		ОстальнаяЧасть = Сред(ОстальнаяЧасть, Индекс + СтрДлина(Разделитель));
		Если Инверсия Тогда
			ДляОбмена = ИзвлекаемаяЧасть;
			ИзвлекаемаяЧасть = ОстальнаяЧасть;
			ОстальнаяЧасть = ДляОбмена;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Функция РазделитьПоПервомуНайденномуРазделителюСервер(Строка, Разделители)
	
	МинимальныйИндекс = СтрДлина(Строка);
	ПервыйРазделитель = "";
	
	Для Каждого Разделитель Из Разделители Цикл
		Индекс = СтрНайти(Строка, Разделитель);
		Если Индекс = 0 Тогда
			Продолжить;
		КонецЕсли;
		Если Индекс < МинимальныйИндекс Тогда
			МинимальныйИндекс = Индекс;
			ПервыйРазделитель = Разделитель;
		КонецЕсли;
	КонецЦикла;
	
	Результат = Новый Массив;
	Если ЗначениеЗаполнено(ПервыйРазделитель) Тогда
		Результат.Добавить(Лев(Строка, МинимальныйИндекс - 1));
		Результат.Добавить(Сред(Строка, МинимальныйИндекс + СтрДлина(ПервыйРазделитель)));
		Результат.Добавить(ПервыйРазделитель);
	Иначе
		Результат.Добавить(Строка);
		Результат.Добавить("");
		Результат.Добавить(Неопределено);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Функция ПолучитьКлючПодписиAWS4(СекретныйКлюч, Дата, Регион, Сервис) Экспорт
	
	КлючДата = ПодписатьСообщениеHMAC("AWS4" + СекретныйКлюч, Дата);
	КлючРегион = ПодписатьСообщениеHMAC(КлючДата, Регион);
	КлючСервис = ПодписатьСообщениеHMAC(КлючРегион, Сервис);
	
	Возврат ПодписатьСообщениеHMAC(КлючСервис, "aws4_request");
	
КонецФункции

&НаСервере
Функция ПодписатьСообщениеHMAC(Знач Ключ, Знач Сообщение, Знач Алгоритм = Неопределено) Экспорт
	
	Если Алгоритм = Неопределено Тогда
		Алгоритм = ХешФункция.SHA256;
	КонецЕсли;
	
	Если ТипЗнч(Ключ) = Тип("Строка") Тогда
		Ключ = ПолучитьДвоичныеДанныеИзСтроки(Ключ, КодировкаТекста.UTF8, Ложь);
	КонецЕсли;
	Если ТипЗнч(Сообщение) = Тип("Строка") Тогда
		Сообщение = ПолучитьДвоичныеДанныеИзСтроки(Сообщение, КодировкаТекста.UTF8, Ложь);
	КонецЕсли;

	Возврат HMAC(Ключ, Сообщение, Алгоритм);
	
КонецФункции

&НаСервере
Функция ЭтоСтандартныйПорт(СтруктураURL)
	
	СтандартныйПортHTTP = 80;
	СтандартныйПортHTTPS = 443;
	
	Возврат (СтруктураURL.Схема = "http" И СтруктураURL.Порт = СтандартныйПортHTTP) 
		ИЛИ (СтруктураURL.Схема = "https" И СтруктураURL.Порт = СтандартныйПортHTTPS);
	
КонецФункции

&НаСервере
Функция СформироватьЗначениеЗаголовкаHost(СтруктураURL)
	
	Host = СтруктураURL.Сервер;
	Если ЗначениеЗаполнено(СтруктураURL.Порт) И НЕ ЭтоСтандартныйПорт(СтруктураURL) Тогда
		Host = Host + ":" + Формат(СтруктураURL.Порт, "ЧРГ=; ЧГ=");
	КонецЕсли;
	
	Возврат Host;
	
КонецФункции

&НаСервере
Функция ПолучитьКаноническиеЗаголовкиAWS4(Заголовки, СтруктураURL) Экспорт
	
	Список = Новый СписокЗначений;
	
	ЗаголовокHostЕстьВЗапросе = Ложь;
	ЗаголовкиПоУмолчанию = ЗаголовкиПоУмолчаниюAWS4();
	Для Каждого ОчереднойЗаголовок Из Заголовки Цикл
		ЗаголовокHTTP = НРег(ОчереднойЗаголовок.Ключ);
		Если ЗаголовкиПоУмолчанию.Исключения.Найти(ЗаголовокHTTP) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ЗаголовокHostЕстьВЗапросе = Макс(ЗаголовокHostЕстьВЗапросе, ЗаголовокHTTP = "host");
		
		Если ЗаголовкиПоУмолчанию.Равно.Найти(ЗаголовокHTTP) <> Неопределено Тогда
			Список.Добавить(ЗаголовокHTTP, СокрЛП(ОчереднойЗаголовок.Значение));
		Иначе
			Для Каждого Префикс Из ЗаголовкиПоУмолчанию.НачинаетсяС Цикл
				Если СтрНачинаетсяС(ЗаголовокHTTP, Префикс) Тогда
					Список.Добавить(ЗаголовокHTTP, СокрЛП(ОчереднойЗаголовок.Значение));
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Если Не ЗаголовокHostЕстьВЗапросе Тогда
		Список.Добавить("host", СформироватьЗначениеЗаголовкаHost(СтруктураURL));
	КонецЕсли;
	
	Список.СортироватьПоЗначению(НаправлениеСортировки.Возр);
	
	КаноническиеЗаголовки = Новый Массив;
	ПодписываемыеЗаголовки = Новый Массив;
	Для Каждого ЭлементСписка Из Список Цикл
		КаноническиеЗаголовки.Добавить(ЭлементСписка.Значение + ":" + ЭлементСписка.Представление);
		ПодписываемыеЗаголовки.Добавить(ЭлементСписка.Значение);
	КонецЦикла;
	КаноническиеЗаголовки.Добавить("");
	
	КаноническиеЗаголовки = СтрСоединить(КаноническиеЗаголовки, Символы.ПС);
	ПодписываемыеЗаголовки = СтрСоединить(ПодписываемыеЗаголовки, ";");
	Возврат Новый Структура(
		"КаноническиеЗаголовки, ПодписываемыеЗаголовки",
		КаноническиеЗаголовки, ПодписываемыеЗаголовки);
	
КонецФункции

&НаСервере
Функция ПолучитьКаноническиеПараметрыЗапросаAWS4(ПараметрыЗапроса) Экспорт
	
	Список = Новый СписокЗначений;
	Для Каждого ОчереднойПараметрЗапроса Из ПараметрыЗапроса Цикл
		Список.Добавить(ОчереднойПараметрЗапроса.Ключ, СокрЛП(ОчереднойПараметрЗапроса.Значение));
	КонецЦикла;
	Список.СортироватьПоЗначению(НаправлениеСортировки.Возр);
	
	КаноническиеПараметры = Новый Массив;
	Для Каждого ЭлементСписка Из Список Цикл
		ЗначениеПараметра = КодироватьСтроку(ЭлементСписка.Представление, СпособКодированияСтроки.КодировкаURL);
		КаноническиеПараметры.Добавить(ЭлементСписка.Значение + "=" + ЗначениеПараметра);
	КонецЦикла;
	
	Возврат СтрСоединить(КаноническиеПараметры, "&");
		
КонецФункции

&НаСервере
Функция ЗаголовкиПоУмолчаниюAWS4()
	
	Заголовки = Новый Структура;
	Заголовки.Вставить("Равно", СтрРазделить("host,content-type,date", ","));
	Заголовки.Вставить("НачинаетсяС", СтрРазделить("x-amz-", ","));
	Заголовки.Вставить("Исключения", СтрРазделить("x-amz-client-context", ","));
	
	Возврат Заголовки;
	
КонецФункции

&НаСервере
Функция ХешированиеДанных(Знач ИмяАлгоритма, Знач Данные) Экспорт
	
	Если ТипЗнч(ИмяАлгоритма) = Тип("Строка") И ВРег(ИмяАлгоритма) = "MD5" Тогда
		Алгоритм = ХешФункция.MD5;
	ИначеЕсли ТипЗнч(ИмяАлгоритма) = Тип("Строка") И ВРег(ИмяАлгоритма) = "CRC32" Тогда
		Алгоритм = ХешФункция.CRC32;
	ИначеЕсли ТипЗнч(ИмяАлгоритма) = Тип("Строка") И ВРег(ИмяАлгоритма) = "SHA1" Тогда
		Алгоритм = ХешФункция.SHA1;
	ИначеЕсли ТипЗнч(ИмяАлгоритма) = Тип("Строка") И ВРег(ИмяАлгоритма) = "SHA256" Тогда
		Алгоритм = ХешФункция.SHA256;
	Иначе
		Алгоритм = ИмяАлгоритма;
	КонецЕсли;
	
	Если ТипЗнч(Данные) = Тип("Строка") Тогда
		Данные = ПолучитьДвоичныеДанныеИзСтроки(Данные, КодировкаТекста.UTF8, Ложь);
	КонецЕсли;
	
	Хеширование = Новый ХешированиеДанных(Алгоритм);
	Хеширование.Добавить(Данные);
	
	Возврат НРег(ПолучитьHexСтрокуИзДвоичныхДанных(Хеширование.ХешСумма));
	
КонецФункции
